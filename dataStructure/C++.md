## 存储
## C++ 内存分区
    栈、堆、自由存储区、全局/静态存储区、常量区

    栈：存放函数的局部变量，由编译器自动分配和释放
    
    堆：动态申请的内存空间，就是由 malloc 分配的内存块，由程序员控制它的分配和释放，如果程序执行结束还没有释放，操作系统会自动回收
    
    自由存储区：和堆十分相似，存放由 new 分配的内存块，由 delete 释放内存
    
    全局区/静态区：存放全局变量和静态变量
    
    常量存储区：存放的是常量，不允许修改

### 如何限制类的对象只能在堆上创建？如何限制对象只能在栈上创建？
    限制类的对象只在堆上创建：
    1.将析构函数设置为私有。
    2.构造函数设置为 protected，并提供一个 public 的静态函数来完成构造，而不是在类的外部使用 new 构造；将析构函数设置为 protected。
    限制类的对象只在栈上创建：
    将 operator new() 设置为私有。
### 内存泄漏
    并非指内存从物理上消失，而是指程序在运行过程中，由于疏忽或错误而失去了对该内存的控制，从而造成了内存的浪费。

    1.常指堆内存泄漏，因为堆是动态分配的，而且是用户来控制的，如果使用不当，会产生内存泄漏。
    使用 malloc、calloc、realloc、new 等分配内存时，使用完后要调用相应的 free 或 delete 释放内存，否则这块内存就会造成内存泄漏。

    2.指针重新赋值(最初指向的内存空间地址丢失)
#### 内存泄漏检测工具的实现原理：
    Memcheck 能够检测出内存问题，关键在于其建立了两个全局表：

    Valid-Value 表：对于进程的整个地址空间中的每一个字节（byte），都有与之对应的 8 个 bits ；对于 CPU 的每个寄存器，也有一个与之对应的 bit 向量。这些 bits 负责记录该字节或者寄存器值是否具有有效的、已初始化的值。

    Valid-Address 表：对于进程整个地址空间中的每一个字节（byte），还有与之对应的 1 个 bit，负责记录该地址是否能够被读写。
    检测原理：

    当要读写内存中某个字节时，首先检查这个字节对应的 Valid-Address 表中对应的 bit。如果该 bit 显示该位置是无效位置，Memcheck 则报告读写错误。
    内核（core）类似于一个虚拟的 CPU 环境，这样当内存中的某个字节被加载到真实的 CPU 中时，该字节在 Valid-Value 表对应的 bits 也被加载到虚拟的 CPU 环境中。一旦寄存器中的值，被用来产生内存地址，或者该值能够影响程序输出，则 Memcheck 会检查 Valid-Value 表对应的 bits，如果该值尚未初始化，则会报告使用未初始化内存错误。

## 类
### 大小
    虚函数对类的大小有影响，是因为虚函数表指针的影响。
    虚继承对类的大小有影响，是因为虚基表指针带来的影响。
    空类的大小是一个特殊情况，空类的大小为 1，当用 new 来创建一个空类的对象时，为了保证不同对象的地址不同，空类也占用存储空间。
    指针所占的空间和指针指向的数据类型无关
    指针大小为8个字节(10个十六进制)
## 智能指针
    除了静态内存和栈内存外，每个程序还有一个内存池，这部分内存被称为自由空间或者堆。程序用堆来存储动态分配的对象即那些在程序运行时分配的对象，当动态对象不再使用时，我们的代码必须显式的销毁它们。
    默认初始化的智能指针中保存着一个空指针。
    智能指针的使用方式和普通指针类似，解引用一个智能指针返回它指向的对象，在一个条件判断中使用智能指针就是检测它是不是空

    1. 共享指针（shared_ptr）：资源可以被多个指针共享，使用计数机制表明资源被几个指针共享。通过 use_count() 查看资源的所有者的个数，可以通过 unique_ptr、weak_ptr 来构造，调用 release() 释放资源的所有权，计数减一，当计数减为 0 时，会自动释放内存空间，从而避免了内存泄漏。

    2. 独占指针（unique_ptr）：独享所有权的智能指针，资源只能被一个指针占有，该指针不能拷贝构造和赋值。但可以进行移动构造和移动赋值构造（调用 move() 函数），即一个 unique_ptr 对象赋值给另一个 unique_ptr 对象，可以通过该方法进行赋值。
    
    借助 std::move() 可以实现将一个 unique_ptr 对象赋值给另一个 unique_ptr 对象，其目的是实现所有权的转移。

    3. 弱指针（weak_ptr）：指向 share_ptr 指向的对象，能够解决由shared_ptr带来的循环引用问题。

    最安全的分配和使用动态内存的方法就是调用一个名为make_shared的标准库函数

    我们可以认为每个shared_ptr都有一个关联的计数器，通常称其为引用计数，无论何时我们拷贝一个shared_ptr，计数器都会递增。当我们给shared_ptr赋予一个新值或是shared_ptr被销毁（例如一个局部的shared_ptr离开其作用域）时，计数器就会递减，一旦一个shared_ptr的计数器变为0,它就会自动释放自己所管理的对象。

    程序使用动态内存的原因：
    （1）程序不知道自己需要使用多少对象
    （2）程序不知道所需对象的准确类型
    （3）程序需要在多个对象间共享数据
    
    int *p1 = new int;//如果分配失败，new抛出std：：bad_alloc
    int *p2 = new (nothrow)int;//如果分配失败，new返回一个空指针

    不要混合使用普通指针和智能指针
    如果混合使用的话，智能指针自动释放之后，普通指针有时就会变成悬空指针，当将一个shared_ptr绑定到一个普通指针时，我们就将内存的管理责任交给了这个shared_ptr。一旦这样做了，我们就不应该再使用内置指针来访问shared_ptr所指向的内存了。

    p = new int(1024);//错误：不能将一个指针赋予shared_ptr
    p.reset(new int(1024));//正确。p指向一个新对象
## 对象
    面向对象的三大特性：

    封装：将具体的实现过程和数据封装成一个函数，只能通过接口进行访问，降低耦合性。

    继承：子类继承父类的特征和行为，子类有父类的非 private 方法或成员变量，子类可以对父类的方法进行重写，增强了类之间的耦合性，但是当父类中的成员变量、成员函数或者类本身被 final 关键字修饰时，修饰的类不能继承，修饰的成员不能重写或修改。

    多态：多态就是不同继承类的对象，对同一消息做出不同的响应，基类的指针指向或绑定到派生类的对象，使得基类指针呈现不同的表现方式。
### 多态
    在类中用 virtual 关键字声明的函数叫做虚函数；
    存在虚函数的类都有一个虚函数表，当创建一个该类的对象时，该对象有一个指向虚函数表的虚表指针（虚函数表和类对应的，虚表指针是和对象对应）；
    当基类指针指向派生类对象，基类指针调用虚函数时，基类指针指向派生类的虚表指针，由于该虚表指针指向派生类虚函数表，通过遍历虚表，寻找相应的虚函数。

## STL
    STL提供了六大组件，彼此之间可以组合套用，这六大组件分别是:容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器。

    容器：各种数据结构，如vector、list、deque、set、map等,用来存放数据，从实现角度来看，STL容器是一种class template。

    算法：各种常用的算法，如sort、find、copy、for_each。从实现的角度来看，STL算法是一种function tempalte.

    迭代器：扮演了容器与算法之间的胶合剂，共有五种类型，从实现角度来看，迭代器是一种将operator* , operator-> , operator++,operator--等指针相关操作予以重载的class template. 所有STL容器都附带有自己专属的迭代器，只有容器的设计者才知道如何遍历自己的元素。原生指针(native pointer)也是一种迭代器。

    仿函数：行为类似函数，可作为算法的某种策略。从实现角度来看，仿函数是一种重载了operator()的class 或者class template

    适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。

    空间配置器：负责空间的配置与管理。从实现角度看，配置器是一个实现了动态空间配置、空间管理、空间释放的class tempalte.
### Strlen 和size of
    strlen 本身是库函数，因此在程序运行过程中，计算长度；而 sizeof 在编译时，计算长度；

    sizeof 的参数可以是类型，也可以是变量；strlen 的参数必须是 char* 类型的变量。
### 隐式转换
    等号两侧是不同类似元素但经过隐式转换后可相互赋值。explicit 可声明在函数前以拒绝隐式转换。
### static
    在 C 语言中，使用 static 可以定义局部静态变量、外部静态变量、静态函数
    在 C++ 中，使用 static 可以定义局部静态变量、外部静态变量、静态函数、静态成员变量和静态成员函数。因为 C++ 中有类的概念，静态成员变量、静态成员函数都是与类有关的概念。

    static 定义静态变量，静态函数。

    static 保持变量内容持久：static 作用于局部变量，改变了局部变量的生存周期，使得该变量存在于定义后直到程序运行结束的这段时间。

    隐藏：static 作用于全局变量和函数，改变了全局变量和函数的作用域，使得全局变量和函数只能在定义它的文件中使用，在源文件中不具有全局可见性。（注：普通全局变量和函数具有全局可见性，即其他的源文件也可以使用。）

    static 作用于类的成员变量和类的成员函数，使得类变量或者类成员函数和类有关，也就是说可以不定义类的对象就可以通过类访问这些静态成员。
    注意：类的静态成员函数中只能访问静态成员变量或者静态成员函数，不能将静态成员函数定义成虚函数。

    （作用全局变量或函数，单文件可见，作用局部变量，变量存在于定以后直到程序运行结束的这段时间，作用于类的成员变量和函数使得可以直接通过类而不是类的对象来调用这些函数）

    静态数据成员的类型可以是所属类的类型，而普通数据成员的类型只能是该类类型的指针或引用。

    static A s_var; // 正确，静态数据成员
    A var;          // error: field 'var' has incomplete type 'A'
    A *p;           // 正确，指针
    A &var1;        // 正确，引用

    静态成员函数不能声明成虚函数（virtual）、const 函数和 volatile 函数。

    static和全局变量的区别：
    作用域：普通全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，普通全局变量在各个源文件中都是有效的；静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其他源文件中引起错误。

    初始化：静态全局变量只初始化一次，防止在其他文件中使用。

### const
    const 修饰成员变量，定义成 const 常量，相较于宏常量，可进行类型检查，节省内存空间，提高了效率。
    const 修饰函数参数，使得传递过来的函数参数的值不能改变。
    const 修饰成员函数，使得成员函数不能修改任何类型的成员变量（mutable 修饰的变量除外），也不能调用非 const 成员函数，因为非 const 成员函数可能会修改成员变量。

    const 成员变量只在某个对象的生存周期内是常量，对于整个类而言却是可变的，因为类可以创建多个对象，不同类的 const 成员变量的值是不同的。因此不能在类的声明中初始化 const 成员变量，类的对象还没有创建，编译器不知道他的值。

### define和const
    编译阶段：define 是在编译预处理阶段进行替换，const 是在编译阶段确定其值。

    安全性：define 定义的宏常量没有数据类型，只是进行简单的替换，不会进行类型安全的检查；const 定义的常量是有类型的，是要进行判断的，可以避免一些低级的错误。
    
    内存占用：define 定义的宏常量，在程序中使用多少次就会进行多少次替换，内存中有多个备份，占用的是代码段的空间；const 定义的常量占用静态存储区的空间，程序运行过程中只有一份。
    
    调试：define 定义的宏常量不能调试，因为在预编译阶段就已经进行替换了；const 定义的常量可以进行调试。

### 内联函数的作用及使用方法
    inline 是一个关键字，可以用于定义内联函数。内联函数，像普通函数一样被调用，但是在调用时并不通过函数调用的机制而是直接在调用点处展开，这样可以大大减少由函数调用带来的开销，从而提高程序的运行效率。

    类内定义成员函数默认是内联函数。
    类外定义成员函数，若想定义为内联函数，需用关键字声明：
    inline void A::fun(){
        cout << var << endl;
    }

    内联函数不是在调用时发生控制转移关系，而是在编译阶段将函数体嵌入到每一个调用该函数的语句块中，编译器会将程序中出现内联函数的调用表达式用内联函数的函数体来替换。
    普通函数是将程序执行转移到被调用函数所存放的内存地址，当函数执行完后，返回到执行此函数前的地方。转移操作需要保护现场，被调函数执行完后，再恢复现场，该过程需要较大的资源开销。

### 宏定义和内联函数的区别
    内联函数是在编译时展开，而宏在编译预处理时展开；在编译的时候，内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换。
    内联函数是真正的函数，和普通函数调用的方法一样，在调用点处直接展开，避免了函数的参数压栈操作，减少了调用的开销。而宏定义编写较为复杂，常需要增加一些括号来避免歧义。
    宏定义只进行文本替换，不会对参数的类型、语句能否正常编译等进行检查。而内联函数是真正的函数，会对参数的类型、函数体内的语句编写是否正确等进行检查。


### vector和list的实现
## 动态内存分配
    new 是 C++ 中的关键字，用来动态分配内存空间，实现方式如下：
    int *p = new int[5]; 
### DELETE
    delete 的实现原理：

    首先执行该对象所属类的析构函数；
    进而通过调用 operator delete 的标准库函数来释放所占的内存空间。
    delete 和 delete [] 的区别：

    delete 用来释放单个对象所占的空间，只会调用一次析构函数；
    delete [] 用来释放数组空间，会对数组中的每个成员都调用一次析构函数。
### new和malloc的区别
    malloc、free 是库函数，而new、delete 是关键字。
    -new 申请空间时，无需指定分配空间的大小，编译器会根据类型自行计算；malloc 在申请空间时，需要确定所申请空间的大小。

    new 申请空间时，返回的类型是对象的指针类型，无需强制类型转换，是类型安全的操作符；malloc 申请空间时，返回的是 void* 类型，需要进行强制类型的转换，转换为对象类型的指针。

    new 分配失败时，会抛出 bad_alloc 异常，malloc 分配失败时返回空指针。

    对于自定义的类型，new 首先调用 operator new() 函数申请空间（底层通过 malloc 实现），然后调用构造函数进行初始化，最后返回自定义类型的指针。
    
    delete 首先调用析构函数，然后调用 operator delete() 释放空间（底层通过 free 实现）。
    
    malloc、free 无法进行自定义类型的对象的构造和析构。
    
    new 操作符从自由存储区上为对象动态分配内存，而 malloc 函数从堆上动态分配内存。（自由存储区不等于堆）

### 堆和自由存储区
    堆区和自由存储区的区别与联系：
    （1）malloc申请的内存在堆上，使用free释放。new申请的内存在自由存储区，用delete释放
    （2）堆（heap）是c语言和操作系统的术语。堆是操作系统所维护的一块特殊内存，它提供了动态分配的功能，当程序运行时调用malloc()时就会从中分配，调用free可把内存交换。而自由存储区是C++中通过new和delete动态分配和释放对象的抽象概念，通过new来申请的内存区域可称为自由存储区。
    基本上，所有的C++编译器默认用堆来实现自由存储区，也即是缺省的全局运算符new和delete也许会按照malloc和free的方式来实现，这时由new运算符分配的对象，说它在堆上也对，说它在自由存储区也对。

    记住：
    （1）堆是c语言和操作系统的术语，是操作系统维护的一块内存。自由存储是C++中通过new和delete动态分配和释放对象的抽象概念。
    （2）new所申请的内存区域在C++中称为自由存储区，编译器用malloc和free实现new和delete操作符时，new申请的内存可以说是在堆上。
    （3）堆和自由内存区有相同之处，但并不等价。


### struct和Class的区别
    struct 和 class 都可以自定义数据类型，也支持继承操作

    struct 中默认的访问级别是 public，默认的继承级别也是 public
    class 中默认的访问级别是 private，默认的继承级别也是 private
    当 class 继承 struct 或者 struct 继承 class 时，默认的继承级别取决于默认的继承级别取决于class或struct本身， class(private 继承) ，struct(public 继承)

### struct 和 union 的区别
    联合体和结构体都是由若干个数据类型不同的数据成员组成。使用时，联合体只有一个有效的成员；而结构体所有的成员都有效。

    对联合体的不同成员赋值，将会对覆盖其他成员的值，而对于结构体的对不同成员赋值时，相互不影响。

    联合体的大小为其内部所有变量的最大值，按照最大类型的倍数进行分配大小；结构体分配内存的大小遵循内存对齐原则。

### volatile 的作用？是否具有原子性，对编译器有什么影响？
    volatile 的作用：当对象的值可能在程序的控制或检测之外被改变时，应该将该对象声明为 volatile，告知编译器不应对这样的对象进行优化。

    volatile不具有原子性。

    volatile 对编译器的影响：使用该关键字后，编译器不会对相应的对象进行优化，即不会将变量从内存缓存到寄存器中，防止多个线程有可能使用内存中的变量，有可能使用寄存器中的变量，从而导致程序错误。

    volatile提醒编译器它后面所定义的变量随时都有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，都会直接从变量地址中读取数据。
    如果没有volatile关键字，则编译器可能优化读取和存储，可能暂时使用寄存器中的值，如果这个变量由别的程序更新了的话，将出现不一致的现象。

### 什么情况下使用volatile
    当多个线程都会用到某一变量，并且该变量的值有可能发生改变时，需要用 volatile 关键字对该变量进行修饰；
    中断服务程序中访问的变量或并行设备的硬件寄存器的变量，最好用 volatile 关键字修饰。
### extern C
    在C++中调用C语言编写的函数

### sizeof(1==1) 在 C 和 C++ 中分别是什么结果？
    C语言
    sizeof（1 == 1） == sizeof（1）按照整数处理，所以是4字节，这里也有可能是8字节（看操作系统）
    C++
    因为有bool 类型：sizeof（1 == 1） == sizeof（true） 按照bool类型处理，所以是1个字节



