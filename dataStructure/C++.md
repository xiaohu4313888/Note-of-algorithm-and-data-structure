## 存储
## C++ 内存分区
    栈、堆、自由存储区、全局/静态存储区、常量区

    栈：存放函数的局部变量，由编译器自动分配和释放
    
    堆：动态申请的内存空间，就是由 malloc 分配的内存块，由程序员控制它的分配和释放，如果程序执行结束还没有释放，操作系统会自动回收
    
    自由存储区：和堆十分相似，存放由 new 分配的内存块，由 delete 释放内存
    
    全局区/静态区：存放全局变量和静态变量
    
    常量存储区：存放的是常量，不允许修改

### 如何限制类的对象只能在堆上创建？如何限制对象只能在栈上创建？
    限制类的对象只在堆上创建：
    1.将析构函数设置为私有。
    2.构造函数设置为 protected，并提供一个 public 的静态函数来完成构造，而不是在类的外部使用 new 构造；将析构函数设置为 protected。
    限制类的对象只在栈上创建：
    将 operator new() 设置为私有。
### 内存泄漏
    并非指内存从物理上消失，而是指程序在运行过程中，由于疏忽或错误而失去了对该内存的控制，从而造成了内存的浪费。

    1.常指堆内存泄漏，因为堆是动态分配的，而且是用户来控制的，如果使用不当，会产生内存泄漏。
    使用 malloc、calloc、realloc、new 等分配内存时，使用完后要调用相应的 free 或 delete 释放内存，否则这块内存就会造成内存泄漏。

    2.指针重新赋值(最初指向的内存空间地址丢失)
#### 内存泄漏检测工具的实现原理：
    Memcheck 能够检测出内存问题，关键在于其建立了两个全局表：

    Valid-Value 表：对于进程的整个地址空间中的每一个字节（byte），都有与之对应的 8 个 bits ；对于 CPU 的每个寄存器，也有一个与之对应的 bit 向量。这些 bits 负责记录该字节或者寄存器值是否具有有效的、已初始化的值。

    Valid-Address 表：对于进程整个地址空间中的每一个字节（byte），还有与之对应的 1 个 bit，负责记录该地址是否能够被读写。
    检测原理：

    当要读写内存中某个字节时，首先检查这个字节对应的 Valid-Address 表中对应的 bit。如果该 bit 显示该位置是无效位置，Memcheck 则报告读写错误。
    内核（core）类似于一个虚拟的 CPU 环境，这样当内存中的某个字节被加载到真实的 CPU 中时，该字节在 Valid-Value 表对应的 bits 也被加载到虚拟的 CPU 环境中。一旦寄存器中的值，被用来产生内存地址，或者该值能够影响程序输出，则 Memcheck 会检查 Valid-Value 表对应的 bits，如果该值尚未初始化，则会报告使用未初始化内存错误。

## 类
### 大小
    虚函数对类的大小有影响，是因为虚函数表指针的影响。
    虚继承对类的大小有影响，是因为虚基表指针带来的影响。
    空类的大小是一个特殊情况，空类的大小为 1，当用 new 来创建一个空类的对象时，为了保证不同对象的地址不同，空类也占用存储空间。
    指针所占的空间和指针指向的数据类型无关
    指针大小为8个字节(10个十六进制)
## 智能指针
    除了静态内存和栈内存外，每个程序还有一个内存池，这部分内存被称为自由空间或者堆。程序用堆来存储动态分配的对象即那些在程序运行时分配的对象，当动态对象不再使用时，我们的代码必须显式的销毁它们。
    默认初始化的智能指针中保存着一个空指针。
    智能指针的使用方式和普通指针类似，解引用一个智能指针返回它指向的对象，在一个条件判断中使用智能指针就是检测它是不是空

    1. 共享指针（shared_ptr）：资源可以被多个指针共享，使用计数机制表明资源被几个指针共享。通过 use_count() 查看资源的所有者的个数，可以通过 unique_ptr、weak_ptr 来构造，调用 release() 释放资源的所有权，计数减一，当计数减为 0 时，会自动释放内存空间，从而避免了内存泄漏。

    2. 独占指针（unique_ptr）：独享所有权的智能指针，资源只能被一个指针占有，该指针不能拷贝构造和赋值。但可以进行移动构造和移动赋值构造（调用 move() 函数），即一个 unique_ptr 对象赋值给另一个 unique_ptr 对象，可以通过该方法进行赋值。
    
    借助 std::move() 可以实现将一个 unique_ptr 对象赋值给另一个 unique_ptr 对象，其目的是实现所有权的转移。

    3. 弱指针（weak_ptr）：指向 share_ptr 指向的对象，能够解决由shared_ptr带来的循环引用问题。

    最安全的分配和使用动态内存的方法就是调用一个名为make_shared的标准库函数

    我们可以认为每个shared_ptr都有一个关联的计数器，通常称其为引用计数，无论何时我们拷贝一个shared_ptr，计数器都会递增。当我们给shared_ptr赋予一个新值或是shared_ptr被销毁（例如一个局部的shared_ptr离开其作用域）时，计数器就会递减，一旦一个shared_ptr的计数器变为0,它就会自动释放自己所管理的对象。

    程序使用动态内存的原因：
    （1）程序不知道自己需要使用多少对象
    （2）程序不知道所需对象的准确类型
    （3）程序需要在多个对象间共享数据
    
    int *p1 = new int;//如果分配失败，new抛出std：：bad_alloc
    int *p2 = new (nothrow)int;//如果分配失败，new返回一个空指针

    不要混合使用普通指针和智能指针
    如果混合使用的话，智能指针自动释放之后，普通指针有时就会变成悬空指针，当将一个shared_ptr绑定到一个普通指针时，我们就将内存的管理责任交给了这个shared_ptr。一旦这样做了，我们就不应该再使用内置指针来访问shared_ptr所指向的内存了。

    p = new int(1024);//错误：不能将一个指针赋予shared_ptr
    p.reset(new int(1024));//正确。p指向一个新对象
## 对象
    面向对象的三大特性：

    封装：将具体的实现过程和数据封装成一个函数，只能通过接口进行访问，降低耦合性。

    继承：子类继承父类的特征和行为，子类有父类的非 private 方法或成员变量，子类可以对父类的方法进行重写，增强了类之间的耦合性，但是当父类中的成员变量、成员函数或者类本身被 final 关键字修饰时，修饰的类不能继承，修饰的成员不能重写或修改。

    多态：多态就是不同继承类的对象，对同一消息做出不同的响应，基类的指针指向或绑定到派生类的对象，使得基类指针呈现不同的表现方式。
### 多态
    在类中用 virtual 关键字声明的函数叫做虚函数；
    存在虚函数的类都有一个虚函数表，当创建一个该类的对象时，该对象有一个指向虚函数表的虚表指针（虚函数表和类对应的，虚表指针是和对象对应）；
    当基类指针指向派生类对象，基类指针调用虚函数时，基类指针指向派生类的虚表指针，由于该虚表指针指向派生类虚函数表，通过遍历虚表，寻找相应的虚函数。

## STL
    STL提供了六大组件，彼此之间可以组合套用，这六大组件分别是:容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器。

    容器：各种数据结构，如vector、list、deque、set、map等,用来存放数据，从实现角度来看，STL容器是一种class template。

    算法：各种常用的算法，如sort、find、copy、for_each。从实现的角度来看，STL算法是一种function tempalte.

    迭代器：扮演了容器与算法之间的胶合剂，共有五种类型，从实现角度来看，迭代器是一种将operator* , operator-> , operator++,operator--等指针相关操作予以重载的class template. 所有STL容器都附带有自己专属的迭代器，只有容器的设计者才知道如何遍历自己的元素。原生指针(native pointer)也是一种迭代器。

    仿函数：行为类似函数，可作为算法的某种策略。从实现角度来看，仿函数是一种重载了operator()的class 或者class template

    适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。

    空间配置器：负责空间的配置与管理。从实现角度看，配置器是一个实现了动态空间配置、空间管理、空间释放的class tempalte.
### Strlen 和size of
    strlen 本身是库函数，因此在程序运行过程中，计算长度；而 sizeof 在编译时，计算长度；

    sizeof 的参数可以是类型，也可以是变量；strlen 的参数必须是 char* 类型的变量。
### 隐式转换
    等号两侧是不同类似元素但经过隐式转换后可相互赋值。explicit 可声明在函数前以拒绝隐式转换。
### static
    在 C 语言中，使用 static 可以定义局部静态变量、外部静态变量、静态函数
    在 C++ 中，使用 static 可以定义局部静态变量、外部静态变量、静态函数、静态成员变量和静态成员函数。因为 C++ 中有类的概念，静态成员变量、静态成员函数都是与类有关的概念。

    static 定义静态变量，静态函数。

    static 保持变量内容持久：static 作用于局部变量，改变了局部变量的生存周期，使得该变量存在于定义后直到程序运行结束的这段时间。

    隐藏：static 作用于全局变量和函数，改变了全局变量和函数的作用域，使得全局变量和函数只能在定义它的文件中使用，在源文件中不具有全局可见性。（注：普通全局变量和函数具有全局可见性，即其他的源文件也可以使用。）

    static 作用于类的成员变量和类的成员函数，使得类变量或者类成员函数和类有关，也就是说可以不定义类的对象就可以通过类访问这些静态成员。
    注意：类的静态成员函数中只能访问静态成员变量或者静态成员函数，不能将静态成员函数定义成虚函数。

    （作用全局变量或函数，单文件可见，作用局部变量，变量存在于定以后直到程序运行结束的这段时间，作用于类的成员变量和函数使得可以直接通过类而不是类的对象来调用这些函数）

    静态数据成员的类型可以是所属类的类型，而普通数据成员的类型只能是该类类型的指针或引用。

    static A s_var; // 正确，静态数据成员
    A var;          // error: field 'var' has incomplete type 'A'
    A *p;           // 正确，指针
    A &var1;        // 正确，引用

    静态成员函数不能声明成虚函数（virtual）、const 函数和 volatile 函数。

    static和全局变量的区别：
    作用域：普通全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，普通全局变量在各个源文件中都是有效的；静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其他源文件中引起错误。

    初始化：静态全局变量只初始化一次，防止在其他文件中使用。

### const
    const 修饰成员变量，定义成 const 常量，相较于宏常量，可进行类型检查，节省内存空间，提高了效率。
    const 修饰函数参数，使得传递过来的函数参数的值不能改变。
    const 修饰成员函数，使得成员函数不能修改任何类型的成员变量（mutable 修饰的变量除外），也不能调用非 const 成员函数，因为非 const 成员函数可能会修改成员变量。

    const 成员变量只在某个对象的生存周期内是常量，对于整个类而言却是可变的，因为类可以创建多个对象，不同类的 const 成员变量的值是不同的。因此不能在类的声明中初始化 const 成员变量，类的对象还没有创建，编译器不知道他的值。

### define和const
    编译阶段：define 是在编译预处理阶段进行替换，const 是在编译阶段确定其值。

    安全性：define 定义的宏常量没有数据类型，只是进行简单的替换，不会进行类型安全的检查；const 定义的常量是有类型的，是要进行判断的，可以避免一些低级的错误。
    
    内存占用：define 定义的宏常量，在程序中使用多少次就会进行多少次替换，内存中有多个备份，占用的是代码段的空间；const 定义的常量占用静态存储区的空间，程序运行过程中只有一份。
    
    调试：define 定义的宏常量不能调试，因为在预编译阶段就已经进行替换了；const 定义的常量可以进行调试。

### 内联函数的作用及使用方法
    inline 是一个关键字，可以用于定义内联函数。内联函数，像普通函数一样被调用，但是在调用时并不通过函数调用的机制而是直接在调用点处展开，这样可以大大减少由函数调用带来的开销，从而提高程序的运行效率。

    类内定义成员函数默认是内联函数。
    类外定义成员函数，若想定义为内联函数，需用关键字声明：
    inline void A::fun(){
        cout << var << endl;
    }

    内联函数不是在调用时发生控制转移关系，而是在编译阶段将函数体嵌入到每一个调用该函数的语句块中，编译器会将程序中出现内联函数的调用表达式用内联函数的函数体来替换。
    普通函数是将程序执行转移到被调用函数所存放的内存地址，当函数执行完后，返回到执行此函数前的地方。转移操作需要保护现场，被调函数执行完后，再恢复现场，该过程需要较大的资源开销。

### 宏定义和内联函数的区别
    内联函数是在编译时展开，而宏在编译预处理时展开；在编译的时候，内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换。
    内联函数是真正的函数，和普通函数调用的方法一样，在调用点处直接展开，避免了函数的参数压栈操作，减少了调用的开销。而宏定义编写较为复杂，常需要增加一些括号来避免歧义。
    宏定义只进行文本替换，不会对参数的类型、语句能否正常编译等进行检查。而内联函数是真正的函数，会对参数的类型、函数体内的语句编写是否正确等进行检查。


### vector和list的实现
## 动态内存分配
    new 是 C++ 中的关键字，用来动态分配内存空间，实现方式如下：
    int *p = new int[5]; 
### DELETE
    delete 的实现原理：

    首先执行该对象所属类的析构函数；
    进而通过调用 operator delete 的标准库函数来释放所占的内存空间。
    delete 和 delete [] 的区别：

    delete 用来释放单个对象所占的空间，只会调用一次析构函数；
    delete [] 用来释放数组空间，会对数组中的每个成员都调用一次析构函数。
### new和malloc的区别
    malloc、free 是库函数，而new、delete 是关键字。
    -new 申请空间时，无需指定分配空间的大小，编译器会根据类型自行计算；malloc 在申请空间时，需要确定所申请空间的大小。

    new 申请空间时，返回的类型是对象的指针类型，无需强制类型转换，是类型安全的操作符；malloc 申请空间时，返回的是 void* 类型，需要进行强制类型的转换，转换为对象类型的指针。

    new 分配失败时，会抛出 bad_alloc 异常，malloc 分配失败时返回空指针。

    对于自定义的类型，new 首先调用 operator new() 函数申请空间（底层通过 malloc 实现），然后调用构造函数进行初始化，最后返回自定义类型的指针。
    
    delete 首先调用析构函数，然后调用 operator delete() 释放空间（底层通过 free 实现）。
    
    malloc、free 无法进行自定义类型的对象的构造和析构。
    
    new 操作符从自由存储区上为对象动态分配内存，而 malloc 函数从堆上动态分配内存。（自由存储区不等于堆）

### 堆和自由存储区
    堆区和自由存储区的区别与联系：
    （1）malloc申请的内存在堆上，使用free释放。new申请的内存在自由存储区，用delete释放
    （2）堆（heap）是c语言和操作系统的术语。堆是操作系统所维护的一块特殊内存，它提供了动态分配的功能，当程序运行时调用malloc()时就会从中分配，调用free可把内存交换。而自由存储区是C++中通过new和delete动态分配和释放对象的抽象概念，通过new来申请的内存区域可称为自由存储区。
    基本上，所有的C++编译器默认用堆来实现自由存储区，也即是缺省的全局运算符new和delete也许会按照malloc和free的方式来实现，这时由new运算符分配的对象，说它在堆上也对，说它在自由存储区也对。

    记住：
    （1）堆是c语言和操作系统的术语，是操作系统维护的一块内存。自由存储是C++中通过new和delete动态分配和释放对象的抽象概念。
    （2）new所申请的内存区域在C++中称为自由存储区，编译器用malloc和free实现new和delete操作符时，new申请的内存可以说是在堆上。
    （3）堆和自由内存区有相同之处，但并不等价。


### struct和Class的区别
    struct 和 class 都可以自定义数据类型，也支持继承操作

    struct 中默认的访问级别是 public，默认的继承级别也是 public
    class 中默认的访问级别是 private，默认的继承级别也是 private
    当 class 继承 struct 或者 struct 继承 class 时，默认的继承级别取决于默认的继承级别取决于class或struct本身， class(private 继承) ，struct(public 继承)

### struct 和 union 的区别
    联合体和结构体都是由若干个数据类型不同的数据成员组成。使用时，联合体只有一个有效的成员；而结构体所有的成员都有效。

    对联合体的不同成员赋值，将会对覆盖其他成员的值，而对于结构体的对不同成员赋值时，相互不影响。

    联合体的大小为其内部所有变量的最大值，按照最大类型的倍数进行分配大小；结构体分配内存的大小遵循内存对齐原则。

### volatile 的作用？是否具有原子性，对编译器有什么影响？
    volatile 的作用：当对象的值可能在程序的控制或检测之外被改变时，应该将该对象声明为 volatile，告知编译器不应对这样的对象进行优化。

    volatile不具有原子性。

    volatile 对编译器的影响：使用该关键字后，编译器不会对相应的对象进行优化，即不会将变量从内存缓存到寄存器中，防止多个线程有可能使用内存中的变量，有可能使用寄存器中的变量，从而导致程序错误。

    volatile提醒编译器它后面所定义的变量随时都有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，都会直接从变量地址中读取数据。
    如果没有volatile关键字，则编译器可能优化读取和存储，可能暂时使用寄存器中的值，如果这个变量由别的程序更新了的话，将出现不一致的现象。

### 什么情况下使用volatile
    当多个线程都会用到某一变量，并且该变量的值有可能发生改变时，需要用 volatile 关键字对该变量进行修饰；
    中断服务程序中访问的变量或并行设备的硬件寄存器的变量，最好用 volatile 关键字修饰。
### extern C
    在C++中调用C语言编写的函数

### sizeof(1==1) 在 C 和 C++ 中分别是什么结果？
    C语言
    sizeof（1 == 1） == sizeof（1）按照整数处理，所以是4字节，这里也有可能是8字节（看操作系统）
    C++
    因为有bool 类型：sizeof（1 == 1） == sizeof（true） 按照bool类型处理，所以是1个字节

## 类
### 纯虚函数
    纯虚函数在类中声明时，加上 =0；
    含有纯虚函数的类称为抽象类（只要含有纯虚函数这个类就是抽象类），类中只有接口，没有具体的实现方法；
    继承纯虚函数的派生类，如果没有完全实现基类纯虚函数，依然是抽象类，不能实例化对象。
### 虚函数与纯虚函数
    虚函数和纯虚函数可以出现在同一个类中，该类称为抽象基类。（含有纯虚函数的类称为抽象基类）
    使用方式不同：虚函数可以直接使用，纯虚函数必须在派生类中实现后才能使用；
    定义形式不同：虚函数在定义时在普通函数的基础上加上 virtual 关键字，纯虚函数定义时除了加上virtual 关键字还需要加上 =0;
    虚函数必须实现，否则编译器会报错；
    对于实现纯虚函数的派生类，该纯虚函数在派生类中被称为虚函数，虚函数和纯虚函数都可以在派生类中重写；
    析构函数最好定义为虚函数，因为因为不是定义为虚函数时，基类型的指针去访问子类，在析构此指针时候，子类的构造函数将不会被调用，这样可能会出现内存泄漏。

    析构函数可以定义为纯虚函数，此时，其所在的类为抽象基类，不能创建实例化对象。

### 虚函数的继承
    ★ 对于父类函数（virtual、非virtual），如果子类没有同名函数，则正常继承

    ★ 对于父类函数（virtual、非virtual），如果子类有同名函数，无同型函数，则不能调用父类函数

    ★ 对于父类函数（virtual、非virtual），如果有同型函数：

    ----非virtual函数由指针类型决定调用哪个

    ----virtual函数由指针指向的对象决定调用哪个（运行时决定）
### 虚函数的实现机制->虚函数表
    虚函数通过虚函数表来实现。虚函数的地址保存在虚函数表中，在类的对象所在的内存空间中，保存了指向虚函数表的指针（称为“虚表指针”），通过虚表指针可以找到类对应的虚函数表。虚函数表解决了基类和派生类的继承问题和类中成员函数的覆盖问题，当用基类的指针来操作一个派生类的时候，这张虚函数表就指明了实际应该调用的函数。


    虚函数表存放的内容：类的虚函数的地址。
    
    虚函数表建立的时间：编译阶段，
    即程序的编译过程中会将虚函数的地址放在虚函数表中。
    
    虚表指针保存的位置：虚表指针存放在对象的内存空间中最前面的位置，
    这是为了保证正确取到虚函数的偏移量。

### 构造函数/析构函数和虚函数
    构造函数一般不定义为虚函数，原因：

    从存储空间的角度考虑：构造函数是在实例化对象的时候进行调用，如果此时将构造函数定义成虚函数，需要通过访问该对象所在的内存空间才能进行虚函数的调用（因为需要通过指向虚函数表的指针调用虚函数表，虽然虚函数表在编译时就有了，但是没有虚函数的指针，虚函数的指针只有在创建了对象才有），但是此时该对象还未创建，便无法进行虚函数的调用。所以构造函数不能定义成虚函数。

    从使用的角度考虑：虚函数是基类的指针指向派生类的对象时，通过该指针实现对派生类的虚函数的调用，构造函数是在创建对象时自动调用的。
    从实现上考虑：虚函数表是在创建对象之后才有的，因此不能定义成虚函数。
    从类型上考虑：在创建对象时需要明确其类型。

    析构函数一般定义成虚函数，原因：
    析构函数定义成虚函数是为了防止内存泄漏，
    因为当基类的指针或者引用指向或绑定到派生类的对象时，如果未将基类的析构函数定义成虚函数，
    会调用基类的析构函数，那么只能将基类的成员所占的空间释放掉，派生类中特有的就会无法释放内存空间导致内存泄漏。(没有定义虚函数时指针的调用将由指针类型决定而非指针指向)

### 如何避免拷贝
    定义一个基类，将其中的拷贝构造函数和赋值构造函数声明为私有 private
    派生类以私有 private 的方式继承基类

### 初始化列表减少开销
    在构造函数中使用类初始化列表，会减少调用默认的构造函数产生的开销

    无论是否在列表中显式初始化成员变量对象，都会在此初始化一次默认构造函数，所以如果不在此处初始化，而是跑到类的构造函数里去初始化的话，等于平白空耗在列表的这次初始化，然后在类的构造函数中再去初始化+拷贝

    因此，使用列表初始化会减少调用默认的构造函数的过程，效率高。


## 虚继承
    使用虚继承的目的：保证存在命名冲突的成员变量/成员函数在派生类中只保留一份

    C++编译系统只执行最后的派生类对虚基类的构造函数的调用，而忽略虚基类的其他派生类对虚基类的构造函数的调用。

### 空类
    空类声明时编译器不会生成任何成员函数：
    对于空类，声明编译器不会生成任何的成员函数，只会生成 1 个字节的占位符。
    当空类 A 定义对象时，sizeof(A) 仍是为 1，但编译器会生成 6 个成员函数：缺省的构造函数、拷贝构造函数、析构函数、赋值运算符、两个取址运算符。

### C++类对象初始化顺序
    构造函数调用顺序：

    按照派生类继承基类的顺序，即派生列表中声明的顺序，依次调用基类的构造函数；

    按照派生类中成员变量的声名顺序，依次调用派生类中成员变量所属类的构造函数；

    执行派生类自身的构造函数。
    综上可以得出，类对象的初始化顺序：基类构造函数–>派生类成员变量的构造函数–>自身构造函数、
    析构函数调用顺序和构造函数相反
### 拷贝构造函数/深拷贝和浅拷贝
    以下情况会调用拷贝构造函数

    1.直接初始化和拷贝初始化时
    string dots("zhang"); //直接初始化
    string dots = "zhang" //拷贝初始化

    2.将一个对象作为实参传递给一个非引用或非指针类型的形参时

    3.从一个返回类型为非引用或非指针的函数返回一个对象时

    4.用花括号列表初始化一个数组的元素或者一个聚合类（很少使用）中的成员时。

    何时调用复制构造函数
    新建一个对象并将其初始化为同类现有对象时，复制构造函数都将被调用。这在很多情况下都可能发生，最常见的情况是新对象显式地初始化为现有的对象。例如，假设motto是一个StringBad对象，则下面4种声明都将调用复制构造函数：
    StringBad ditto(motto);
    StringBad metoo = motto;
    StringBad also = StringBad(motto);
    StringBad * pStringBad = new StringBad(motto);

    不传入引用只能做到浅拷贝，并且传参过程种还会有拷贝和析构的开销

### 实例化一个对象需要哪几个阶段
    分配空间
    创建类对象首先要为该对象分配内存空间。不同的对象，为其分配空间的时机未必相同。全局对象、静态对象、分配在栈区域内的对象，在编译阶段进行内存分配；存储在堆空间的对象，是在运行阶段进行内存分配。

    初始化
    首先明确一点：初始化不同于赋值。初始化发生在赋值之前，初始化随对象的创建而进行，而赋值是在对象创建好后，为其赋上相应的值。
    这一点可以联想下上一个问题中提到：初始化列表先于构造函数体内的代码执行，初始化列表执行的是数据成员的初始化过程，这个可以从成员对象的构造函数被调用看的出来。
    
    赋值
    对象初始化完成后，可以对其进行赋值。对于一个类的对象，其成员变量的赋值过程发生在类的构造函数的函数体中。当执行完该函数体，也就意味着类对象的实例化过程完成了。
    （总结：构造函数实现了对象的初始化和赋值两个过程，对象的初始化是通过初始化列表来完成，而对象的赋值则才是通过构造函数的函数体来实现。）
    注：对于拥有虚函数的类的对象，还需要给虚表指针赋值。

    没有继承关系的类，分配完内存后，首先给虚表指针赋值，然后再列表初始化以及执行构造函数的函数体，即上述中的初始化和赋值操作。
    有继承关系的类，分配内存之后，首先进行基类的构造过程，然后给该派生类的虚表指针赋值，最后再列表初始化以及执行构造函数的函数体，即上述中的初始化和赋值操作。


### 友元
    1.普通函数定义为友元函数，使普通函数能够访问类的私有成员。
    2.友元类：类之间共享数据。
    在继承体系中，友元关系不能被继承，虽然 C 类继承了 B 类，B 类是 Base 类的友元，但是 C 类和 Base 类没有友元关系。

### 静态绑定及动态绑定
    静态类型和动态类型：

    静态类型：变量在声明时的类型，是在编译阶段确定的。静态类型不能更改。
    动态类型：目前所指对象的类型，是在运行阶段确定的。动态类型可以更改。
    静态绑定和动态绑定：

    静态绑定是指程序在 编译阶段 确定对象的类型（静态类型）。
    动态绑定是指程序在 运行阶段 确定对象的类型（动态类型）。
    静态绑定和动态绑定的区别：

    发生的时期不同：如上。
    对象的静态类型不能更改，动态类型可以更改。

### 左值引用和右值引用
    左值引用不能绑定到要转换的表达式、字面常量或返回右值的表达式，通过 & 获得。右值引用恰好相反，可以绑定到这类表达式，但不能绑定到一个左值上。

    右值引用必须绑定到右值的引用，通过 && 获得。右值引用只能绑定到一个将要销毁的对象上，因此可以自由地移动其资源。

    std::move 可以将一个左值强制转化为右值，继而可以通过右值引用使用该值，以用于移动语义。

    static_cast是一个c++运算符，功能是把一个表达式转换为某种类型

### C++ 11 nullptr 比 NULL 优势
    NULL：预处理变量，是一个宏，它的值是 0，定义在头文件 <cstdlib> 中，即 #define NULL 0。
    nullptr：C++ 11 中的关键字，是一种特殊类型的字面值，可以被转换成任意其他类型。

### 指针和引用的区别
    指针所指向的内存空间在程序运行过程中可以改变，而引用所绑定的对象一旦绑定就不能改变。（是否可变）
    指针本身在内存中占有内存空间，引用相当于变量的别名，在内存中不占内存空间。（是否占内存）
    指针可以为空，但是引用必须绑定对象。（是否可为空）
    指针可以有多级，但是引用只能一级。（是否能为多级）












