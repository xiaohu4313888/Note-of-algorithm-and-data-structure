### Build
    Build是将源代码转换为可执行文件的过程，在C/C++中，Build过程大体上分为三步：

    1.预处理（Preprocessing）
    2.编译（Compiling）
    3.链接（Linking）

### 编译和链接
       在此，我想多说关于程序编译的一些规范和方法，一般来说，无论是C、C++、还是pas，首先要把源文件编译成'中间代码文件'，在Windows下也就是 .obj 文件，UNIX下是 .o 文件，即 Object File，这个动作叫做编译（compile）。
       然后再把大量的Object File合成执行文件，这个动作叫作链接（link）。   
     
       编译时，编译器需要的是语法的正确，函数与变量的声明的正确。对于后者，通常是你需要告诉编译器头文件的所在位置（头文件中应该只是声明，而定义应该放在C/C++文件中），只要所有的语法正确，编译器就可以编译出中间目标文件。一般来说，每个源文件都应该对应于一个中间目标文件（O文件或是OBJ文件）。 
       链接时，主要是链接函数和全局变量，所以，我们可以使用这些中间目标文件（O文件或是OBJ文件）来链接我们的应用程序。
       链接器并不管函数所在的源文件，只管函数的中间目标文件（Object File），在大多数时候，由于源文件太多，编译生成的中间目标文件太多，而在链接时需要明显地指出中间目标文件名，
       
       这对于编译很不方便，所以，我们要给中间目标文件打个包，在Windows下这种包叫“库文件”（Library File)，也就是 .lib 文件，在UNIX下，是Archive File，也就是 .a 文件。

      总结一下，源文件首先会生成中间目标文件，再由中间目标文件生成执行文件。在编译时，编译器只检测程序语法，和函数、变量是否被声明。如果函数未被声明，编译器会给出一个警告，但可以生成Object File。而在链接程序时，链接器会在所有的Object File中找寻函数的实现，如果找不到，那到就会报链接错误码（Linker Error），在VC下，这种错误一般是：Link 2001错误，意思说是说，链接器未能找到函数的实现。你需要指定函数的ObjectFile.
### 生成中间件也即.o
       main.o : main.c defs.h

           cc -c main.c #编译但不链接
### 预处理
    cpp文件首先预处理变为translation unit，translation unit仍然是文本代码文件，它是传入编译器的基本单元，把cpp和h整合到了一起，并且去掉不必要的空格 / 换行之类的。
### 编译
    translation unit传入编译器（compiler）之后会被编译成obj文件（二进制）。
    即：高级语言->汇编语言->机器语言（二进制）
    一般而言，生成的都是obj，但如果你想写一个第三方库文件，那么编译器会对应的生成lib（静态链接库）或者dll（动态链接库）文件。

    每一个cpp生成一个translation unit，然后编译生成一个obj，所以cpp与obj是一一对应的，每一个cpp都会独立编译出来一个obj文件。
### 链接
    如果不依赖动态链接库或静态链接库，链接就是把所有obj链接；如果还依赖外部库，链接还包括lib文件。
    注意：这里不包括dll文件，因为dll文件是在运行时才链接进来（其实也不应该叫链接，总之就是运行时才会加载进来，不会在链接生成exe的时候进来）

    为什么要使用dll:
    1. 减小可执行文件exe的大小
    当操作系统进入Windows时代后，其大小已经达到几十兆乃至几百兆。试想如果还是使用DOS时代的单执行文件体系的话一个可执行文件的大小可能将达到数十兆.
    解决的方法就是采用动态链接技术将一个大的可执行文件分割成许多小的可执行程序。
    2. 实现资源共享
    这里指的资源共享包括很多方面，最多的是内存共享、代码共享等等。早期的程序员经常碰到这样的事情，在不同的编程任务中编写同样的代码。这种方法显然浪费了很多时间，为了解决这个问题人们编写了各种各样的库。但由于编程语言和环境的不同这些库一般都不能通用，而且用户在运行程序时还需要这些库才行，极不方便。DLL的出现就像制定了一个标准一样，使这些库有了统一的规范。这样一来，用不同编程语言的程序员可以方便的使用用别的编程语言编写的DLL。另外，DLL还有一个突出的特点就是在内存中只装载一次，这一点可以节省有限的内存，而且可以同时为多个进程服务。
    3. 便于维护和升级
    细心的朋友可能发现有一些DLL文件是有版本说明的。（查看DLL文件的属性可以看到，但不是每一个DLL文件都有）这是为了便于维护和升级。举个例子吧，早期的Win95中有一个BUG那就是在闰年不能正确显示2月29日这一天。后来，Microsoft发布了一个补丁程序纠正了这个BUG。值得一提的是，我们并没有重装Win95，而是用新版本的DLL代替了旧版本的DLL。另一个常见的例子是驱动程序的升级。例如，著名的DirectX就多次升级，现在已经发展到了6.0版了。更妙的是，当我们试图安装较低版本的DLL时，系统会给我们提示，避免人为的操作错误。例如我们升级某硬件的驱动程序时，经常碰到Windows提示我们当前安装的驱动程序比原来的驱动程序旧。
    4. 比较安全
    这里说的安全也包括很多方面。比如，DLL文件遭受病毒的侵害机率要比普通的EXE文件低很多。另外，由于是动态链接的，这给一些从事破坏工作的“高手”们多少带来了一些反汇编的困难。

### 编译
    .o 就相当于windows里的obj文件 ，一个.c或.cpp文件对应一个.o文件 
    .a 是好多个.o合在一起,用于静态连接 ，即STATIC mode，多个.a可以链接生成一个exe的可执行文件 
    .so 是shared object,用于动态连接的,和windows的dll差不多，使用时才载入。

### CMake做的工作
    1. configure 进行配置，生成需要的文件夹及准备文件
    2. generate生成工程文件，如果编译器选择vs，则生成vs工程文件，如果是ubuntu，则生成makefile

### Makefile语法
    调用Shell变量，需要在美元符号前，再加一个美元符号，这是因为Make命令会对美元符号转义。
    正常情况下，make会打印每条命令，然后再执行，这就叫做回声（echoing）。
    在命令的前面加上@，就可以关闭回声。
    命令（commands）表示如何更新目标文件，由一行或多行的Shell命令组成。它是构建"目标"的具体指令，它的运行结果通常就是生成目标文件。
    每行命令在一个单独的shell中执行。这些Shell之间没有继承关系。
    两行命令写在一行，中间需要用分号分隔。也可以写两行分好后加反斜杠表示同意Shell中顺序执行。或在开头添加.ONESHELL:
    Make命令提供一系列内置变量，比如，$(CC) 指向当前使用的编译器，$(MAKE) 指向当前使用的Make工具。

### Makefile 中的自动变量
    $@  $@指代当前目标，就是Make命令当前构建的那个目标。比如，make foo的 $@ 就指代foo。
    a.txt b.txt: 
        touch $@
    等同于下面的写法：
    a.txt:
        touch a.txt
    b.txt:
        touch b.txt
### 代码编译 Compile、Make、Build 的区别
    1、Compile：只编译选定的目标，不管之前是否已经编译过。

    2、Make：编译选定的目标，但是Make只编译上次编译变化过的文件，减少重复劳动，节省时间。（具体怎么检查未变化，这个就不用考虑了，IDE自己内部会搞定这些的）

    3、Build：是对整个工程进行彻底的重新编译，而不管是否已经编译过。Build过程往往会生成发布包，这个具体要看对IDE的配置了，Build在实际中应用很少，因为开发时候基本上不用，发布生产时候一般都用ANT等工具来发布。Build因为要全部编译，还要执行打包等额外工作，因此时间较长。

### Makefile的执行顺序
    在linux下，makefile的执行实际上分为两个阶段进行
    第一阶段：读取所有的makefile文件（包括“MAKEFILES”变量指定的、指示符“include”指定的、以及命令行选项“-f（–file）”指定的makefile文件），内建的变量、明确规则和隐含规则，并建立所有目标和依赖之间的依赖关系结构链表。
    第二阶段：根据第一阶段已经建立的依赖关系结构链表决定哪些目标需要更新，并使用对应的规则来重建这些目标。

make的执行过程如下：
1. 依次读取变量“MAKEFILES”定义的makefile文件列表
2. 读取工作目录下的makefile文件（缺省的是根据命名的查找顺序“GNUmakefile”，“makefile”，“Makefile”，首先找到那个就读取那个）
3. 依次读取工作目录makefile文件中使用指示符“include”包含的文件
4. 查找重建所有已读取的makefile文件的规则（如果存在一个目标是当前读取的某一个makefile文件，则执行此规则重建此makefile文件，完成以后从第一步开始重新执行）
5. 初始化变量值并展开那些需要立即展开的变量和函数并根据预设条件确定执行分支
6. 根据“终极目标”以及其他目标的依赖关系建立依赖关系链表
7. 执行除“终极目标”以外的所有的目标的规则（规则中如果依赖文件中任一个文件的时间戳比目标文件新，则使用规则所定义的命令重建目标文件）
8. 执行“终极目标”所在的规则

